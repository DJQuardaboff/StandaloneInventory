import com.android.build.gradle.internal.dsl.SigningConfig
import org.apache.commons.io.FilenameUtils

import java.nio.file.Paths

apply plugin: 'com.android.application'
apply from: 'plc_systems.gradle'
apply from: 'version.gradle'

def signingFilePath = 'signing.gradle'
def performSigning = file(signingFilePath).exists()
if (performSigning) {
    apply from: signingFilePath
}

private static int generateVersionCode(def version) {
    return (version.major * 10000) + (version.minor * 100) + version.patch
}

private static String generateVersionName(def version) {
    String versionName = "${version.major}.${version.minor}.${version.patch}"
    if (version.suffix != null) {
        versionName += "-" + version.suffix
    }
    return versionName
}

android {
    compileSdkVersion 29
    buildToolsVersion '29.0.1'
    defaultConfig {
        targetSdkVersion 29
        minSdkVersion 23
        versionCode generateVersionCode(plc_version)
        versionName generateVersionName(plc_version)
        //testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            if (performSigning) {
                def signingConfig = new SigningConfig("release")
                        .setStoreFile(file(plc_signing.storeFilePath))
                        .setStorePassword(plc_signing.storePassword)
                        .setKeyAlias(plc_signing.keyAlias)
                        .setKeyPassword(plc_signing.keyPassword)
                signingConfig.setV1SigningEnabled(plc_signing.v1SigningEnabled)
                signingConfig.setV2SigningEnabled(plc_signing.v2SigningEnabled)
                setSigningConfig(signingConfig)
            } else {
                logger.log(LogLevel.WARN, 'No signing config found, release apks will not be signed')
            }
            //minifyEnabled true
            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            applicationIdSuffix '.debug'
            debuggable true
        }
    }
    flavorDimensions 'system', 'scannerSdk'
    productFlavors {
        janam_xm5 {
            dimension 'scannerSdk'
        }
        janam {
            dimension 'scannerSdk'
        }
        zebra {
            dimension 'scannerSdk'
        }
    }

    for (def system : plc_systems) {
        productFlavors.create(system.key, {
            dimension 'system'
            def settings = system.value
            applicationId "com.porterlee.${system.key}.inventory"
            resValue 'string', 'app_name', "${settings.name} Inventory"

            // BarcodeType item
            def item = settings.item
            buildConfigField 'boolean', 'typeItem_hasCustodyOf', item.hasCustodyOf ? 'true' : 'false'
            buildConfigField 'boolean', 'typeItem_hasLabCode', item.hasLabCode ? 'true' : 'false'
            buildConfigField 'String', 'typeItem_base32Prefix', item.base32Prefix ? "\"${item.base32Prefix}\"" : 'null'
            buildConfigField 'String', 'typeItem_base64Prefix', item.base64Prefix ? "\"${item.base64Prefix}\"" : 'null'
            buildConfigField 'String[]', 'typeItem_otherPrefixes', item.otherPrefixes ? "{\"${item.otherPrefixes.join('", "')}\"}" : 'null'
            // BarcodeType item

            // BarcodeType container
            def container = settings.container
            buildConfigField 'boolean', 'typeContainer_hasCustodyOf', container.hasCustodyOf ? 'true' : 'false'
            buildConfigField 'boolean', 'typeContainer_hasLabCode', container.hasLabCode ? 'true' : 'false'
            buildConfigField 'String', 'typeContainer_base32Prefix', container.base32Prefix ? "\"${container.base32Prefix}\"" : 'null'
            buildConfigField 'String', 'typeContainer_base64Prefix', container.base64Prefix ? "\"${container.base64Prefix}\"" : 'null'
            buildConfigField 'String[]', 'typeContainer_otherPrefixes', container.otherPrefixes ? "{\"${container.otherPrefixes.join('", "')}\"}" : 'null'
            // BarcodeType container

            // BarcodeType location
            def location = settings.location
            buildConfigField 'boolean', 'typeLocation_hasCustodyOf', location.hasCustodyOf ? 'true' : 'false'
            buildConfigField 'boolean', 'typeLocation_hasLabCode', location.hasLabCode ? 'true' : 'false'
            buildConfigField 'String', 'typeLocation_base32Prefix', location.base32Prefix ? "\"${location.base32Prefix}\"" : 'null'
            buildConfigField 'String', 'typeLocation_base64Prefix', location.base64Prefix ? "\"${location.base64Prefix}\"" : 'null'
            buildConfigField 'String[]', 'typeLocation_otherPrefixes', location.otherPrefixes ? "{\"${location.otherPrefixes.join('", "')}\"}" : 'null'
            // BarcodeType location

            buildConfigField 'boolean', 'display_quantity', settings.display_quantity ? 'true' : 'false'
        })
    }

    def publishAll = project.tasks.create("publishAll")
    def publishBuildTypes = new HashMap<String, Task>()
    buildTypes.each {
        buildType ->
            def taskName = "publish" + buildType.name.capitalize()
            publishBuildTypes.put(buildType.name, project.tasks.create(taskName))
    }
    applicationVariants.all {
        variant ->
            def inFile
            variant.outputs.all {
                variantOutput ->
                    inFile = variantOutput.outputFile
            }
            if (inFile != null) {
                def has_signingConfig = variant.signingConfig != null
                def outDir = Paths.get(buildDir.path, variant.buildType.name, variant.productFlavors[1].name, 'v' + variant.versionName).toString()
                String outName = plc_systems[variant.productFlavors[0].name].name + 'Inventory'
                if (variant.buildType.debuggable) outName += '-debug'
                if (!has_signingConfig) outName += '-unsigned'
                def task = project.tasks.create("publish${variant.name.capitalize()}") {
                    task ->
                        task.dependsOn variant.assembleProvider
                        task.doLast {
                            if (!has_signingConfig) {
                                logger.log(LogLevel.WARN, "Variant '${variant.name}' does not have a signingConfig, will be unsigned")
                            }
                            copy {
                                from inFile
                                into outDir
                                rename(FilenameUtils.getBaseName(inFile.name), outName)
                            }
                        }
                }
                publishAll.dependsOn task
                publishBuildTypes[variant.buildType.name].dependsOn task
            }
    }
}

dependencies {
    janam_xm5Implementation project(':plc_scanners-janam_XM5Release')
    janamImplementation project(':plc_scanners-janam_XT2_XT2__XM75_XT100_XG200Release')
    zebraImplementation project(':plc_scanners-zebra_emdk_symbol_26Release')

    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'androidx.recyclerview:recyclerview:1.0.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'me.zhanghai.android.materialprogressbar:library:1.6.1'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.2.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}
